% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/aggregateCount.R
\name{aggregateCount}
\alias{aggregateCount}
\title{aggregateCount}
\usage{
aggregateCount(count_df, tax_df = NULL, aggregate_by = NULL)
}
\arguments{
\item{count_df}{dataframe. count table with samples in columns and
ASV in rows. feature IDs in row names.}

\item{tax_df}{dataframe. featureID column should
match rownames of \code{count_df}.
Has columns \code{'Kingdom','Phylum',
'Class','Order','Family','Genus','Species'}.
Can also have \code{Taxon} column (see details).}

\item{aggregate_by}{Aggregate counts by taxonomic level.
Set to \code{NULL} to keep reads at ASV level. default \code{NULL} .
Must be one of \code{c('Kingdom','Phylum','Class','Order','Family',
'Genus','Species')}.}
}
\value{
returns a list of aggregated count table
    (\code{count_df}) and updated taxonomy table (\code{tax_df})
}
\description{
Aggregate read counts based on taxonomic level
}
\details{
If \code{tax_df} has sequences column and features are aggregated,
the sequence column is set to NA. If tax_df has Taxon column with
notation of p__phylum;c__class;o__order... then those are truncated
at the aggregation level.

All taxa downstream of aggregation level are set to NA

The aggregated taxonomy table has an additional column, \code{n_collapse},
which is the number of ASVs that were aggregated.
}
\examples{
data(dss_example)
# featureID should be row names
feature_count <- dss_example$merged_abundance_id \%>\%
  tibble::column_to_rownames('featureID')

# cleanup sample names
colnames(feature_count) <- paste0('id', colnames(feature_count))
feature_tax <- dss_example$merged_taxonomy

# set row order of count and tax tables to be the same
feature_count <- feature_count[feature_tax$featureID,]
aggregated_list <- aggregateCount(feature_count, feature_tax,
                                  aggregate_by = "Family")

summary(aggregated_list)
}
